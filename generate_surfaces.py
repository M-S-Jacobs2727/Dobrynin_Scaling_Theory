import collections
import numpy as np
import pandas as pd
import scipy.interpolate
import json
import generate_data
import grid_clean

Bin = collections.namedtuple('Bin', ['min', 'max', 'num_bins'])

def generate_surface_bins():
    """
    Read json file "surface_bins.json" to output bins to create (nw, phi, eta_sp) space
    
        Arguments:
            None

        Returns:
            Parameters: (dict) Dictionary of tuples. Number of bins [0], minimum bin [1] and maximum bin [2] for each coordinate of Nw, phi, and eta_sp
    """

    with open('surface_bins_nested.json') as f:
        bin_data = json.load(f)

    bins = {}
    bins['Nw'] = Bin(bin_data['Nw']['min'], bin_data['Nw']['max'], bin_data['Nw']['len'])
    bins['phi'] = Bin(bin_data['phi']['min'], bin_data['phi']['max'], bin_data['phi']['len'])
    bins['eta_sp'] = Bin(bin_data['eta_sp']['min'], bin_data['eta_sp']['max'], bin_data['eta_sp']['len'])

    return bins

def bin_data(df, bins, Bg, Bth):
    """
    Create a grid of specific viscosity vs (Nw, phi) for each value of Bg, Bth, and Pe
    
        Arguments:
            df: (DataFrame) DataFrame generated by generate_data.py
            bins: (Dictionary) Input parameters that determine bounds of (Nw, phi, eta_sp) space and number of bins in each dimension
            Bg: (float) B-parameter in good regime
            Bth: (float) B-parameter in theta regime
        Returns:
            None
    """

    df2 = df.copy()
    # define features
    features = ['Nw', 'phi', 'eta_sp']
    # log before normalizing (nw, phi, eta_sp) space
    df2[features] = np.log10(df2[features])
    # normalize (nw, phi, eta_sp) space to (0, 1)
    df2['Nw'] = (df2['Nw']-np.log10(bins['Nw'].min)) / (np.log10(bins['Nw'].max)-np.log10(bins['Nw'].min))
    df2['phi'] = (df2['phi']-np.log10(bins['phi'].min))/(np.log10(bins['phi'].max)-np.log10(bins['phi'].min))
    df2['eta_sp'] = (df2['eta_sp']-np.log10(bins['eta_sp'].min))/(np.log10(bins['eta_sp'].max)-np.log10(bins['eta_sp'].min))

    # set path of save folder
    path1 = 'grid_data_32x32\\'
    for k in np.unique(df2['Pe']):
        # take data for each Pe
        data = df2[df2['Pe']==k]
        x = data['Nw']
        y = data['phi']
        z = data['eta_sp']
        # set up (0,1) mesh grid space, each bin represents a location of (nw, phi)
        xplotv = np.linspace(0,1,bins['Nw'].num_bins)
        yplotv = np.linspace(0,1,bins['phi'].num_bins)
        xplot, yplot = np.meshgrid(xplotv, yplotv)

        # 'linear' method gives values within [0,1]
         # Maybe deal with edges or zero values with nearest method?
        zgriddata_nn = scipy.interpolate.griddata(
            np.array([x.ravel(),y.ravel()]).T,
            z.ravel(),
            np.array([xplot.ravel(),yplot.ravel()]).T,
            method='nearest')

        zgriddata = scipy.interpolate.griddata(
            np.array([x.ravel(),y.ravel()]).T,
            z.ravel(),
            np.array([xplot.ravel(),yplot.ravel()]).T,
            method='linear',
            fill_value=0)

        # each bin of data_save represents a value of normalized eta_sp given data of normalized (nw, phi)
        data_save = zgriddata.reshape(bins['phi'].num_bins,bins['Nw'].num_bins)

        # get values from high phi values using nearest method from griddata
        data_save_nn = zgriddata_nn.reshape(bins['phi'].num_bins,bins['Nw'].num_bins)

        # get edges of grid surface, define 1's in area where eta_sp at high nw and phi are labeled zeros
        data_save = grid_clean.surface_edge(data_save, data_save_nn)

        # save file
        np.savetxt(f'{path1}Bg_{Bg:.2f}_Bth_{Bth:.2f}_Pe_{k:.1f}.txt', data_save)

# Main
def main():
    path_read = 'generated_data_64x64\\'
    grid = generate_data.generate_grid()
    bins = generate_surface_bins()
    for a in grid['Bg']:
        for b in grid['Bth']:
            df = pd.read_csv(f"{path_read}dataset_{a:.2f}_{b:.2f}.csv")
            bin_data(df, bins, a, b)

if __name__ == '__main__':
    main()